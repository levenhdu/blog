<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[设计模式-原则模式]]></title>
    <url>%2F2017%2F03%2F09%2F170309-designmodel%2F</url>
    <content type="text"><![CDATA[设计模式-原则模式 设计原则: 1.找出应用需要变化之处，独立出来 2.面向接口编程，而不是面向实现编程 3.多用组合，少用继承 4.为了交互对象之间的松耦合设计而努力 5.类应该对扩展开放，对修改关闭 6.要依赖抽象，不要依赖具体类(依赖倒置原则)，不能让高层组件依赖低层组件 7.最少知识原则:只和你的密友谈话 8.好莱坞原:别调用（打电话给）我们，我们会调用（打电话给）你，高层组件来决定调用低层组件 9.一个类应该只有一个引起变化的原因 策略模式: 定义了算法族，分别封装起来，让他们直接可以替换，让算法的变化独立于使用算法的客户。 观察者模式: 定义了对象之间的一对多关系，当一个对象改变状态时，它所有的依赖者都会收到通知并自动更新。 装饰者模式: 动态地将责任附加到对象上。若要扩展功能，装饰着提供了比继承更有弹性的替代方案。 工厂方法模式: 定义一个创建对象的接口，但由子类决定要实例化的具体类。工厂方法让类把实例化推迟到子类。 抽象工厂模式: 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 单件模式: 确保一个类只有一个实例，并提供一个全局访问点。 命令模式: 将”请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 适配器模式: 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 外观模式: 提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。 模板方法模式: 在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的一些步骤。 迭代器模式: 提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。 组合模式: 允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方法处理个别对象以及对象组合 状态模式: 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 代理模式: 为另一个对象提供一个替身或占位符以控制对这个对象的访问]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git基本操作]]></title>
    <url>%2F2017%2F01%2F19%2F170119-git-base%2F</url>
    <content type="text"><![CDATA[git基本操作 版本控制系统发展 本地版本控制系统：通过简单的数据库记录文件的历次更新差异(文件补丁) 集中化的版本控制系统（CVCS）：为了满足不同系统的开发者进行协作，出现集中化的VCS,通过一个集中管理的服务器，保存所有版本的修订版本，但由于服务单点，一旦中央服务出现宕机的情况，或者数据损坏，丢失数据的风险很大 分布式版本控制（DVCS）:客户端在与服务端更新的时候，不只提取最新版本的文件快照，而且还把代码仓库镜像下来，所以一旦服务器丢失文件数据，可以用任何一个镜像的本地仓库来恢复 git特性 直接记录快照，每一个版本都一个对应的快照 几乎所有操作都是本地操作 三个工作区域：工作目录（workinging tree），暂存区域(cached area)，以及本地仓库(repository)。下图就可以知道他们的交互： git配置 存储位置 /etc/gitconfig 对所有用户都适用的配置 ~/.gitconfig 对当前用户适用的配置 .git/config 对当前项目适用的配置 用户信息配置 git config --global user.name &quot;leven&quot; git config --global user.email levenhdu@163.com git config --list 查看配置 git config user.name 查看指定配置信息 获取帮助 git help [command] 可以通过该命令获取对应帮助信息 git操作 初始化仓库 git init git初始化，会在当前目录生成.git目录 git add 将文件加入版本控制，索引文件（index files），也就是放入暂存区域(cached area) git clone (repority url) [localPath] 从现有的仓库中克隆一份项目,最后可以指定存储位置 检查当前文件状态 文件状态生命周期 git status [-s 简略显示] 查看当前所有文件状态 指定忽略文件 所有空行或者以注释符号＃开头的行都会被 Git 忽略 匹配模式最后跟反斜杠（/）说明要忽略的是目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 1*.a #忽略所有.a结尾的文件 1a/ #忽略a目录下所有文件 1!b.a #b.a为例外 文件比较 git diff 比较working tree和cached area的文件变更 git diff --cached 比较cached area与repository的文件变更 git diff --head 比较working tree和repository的文件变更 文件提交 git commit [-m 增加提交内容备注|-a 将所有纳入版本控制的working tree文件加入暂存区并提交] 文件移除 git rm [-f 如果文件已放入暂存区，需要强制删除] git rm --cached 如果不想删除 working tree的文件，只是从追踪文件中去除 git rm \*log 其中反斜杠+*表示递归删除,将递归删除目录下所有log结尾的文件 git rm *log 如果只想删除当前目录下，可使用该命令 文件恢复 git checkout -- file 修改的区域是工作区,如果工作区有些不想要的修改，可以使用此命令，将暂存区的文件覆盖工作区 git checkout HEAD file 修改的区域是工作区,如果工作区有些不想要的修改，可以使用此命令，将仓库最新版本的文件覆盖工作区(从HEAD可想而知，也可以回退到之前的提交版本git checkout [提交版本号] file) git reset [HEAD 不填默认为最新版本] --file 修改的区域是暂存区，如果暂存区有些不想要的修改，可以使用此命令，将仓库最新版本文件覆盖暂存区 git commit --amend -m 当提交了一个版本，发现少提交了一个文件，或想修改一下提交说明，可以在提交之后使用这一句 文件重命名 git mv 文件重命名，相当于是 1.mv a b 2.git rm a 3.git add b 三个步骤 在windows中git默认不区分大小写，如果直接修改文件大小写，可能识别不出，推荐使用git mv，或修改git config 使之区分大小写git config core.ignorecase false 查看文件提交记录 git log 1234567git log git log -p 比较每个版本差异 git log -2 查看最新的2条提交 git log --stat 查看提交摘要 git log --gragh 图形化显示 git log --pretty=oneline|full|short|format="%h - %s" 使用其他格式 git log --pretty=format:"%h - %s" --author=leven --since="2008-10-01" --before="2008-11-01" 格式参考 远程仓库使用 远程仓库是放在网络上的项目仓库，一般公司中都会有自己独立的远程仓库用于代码管理 远程仓库关联查看 git remote 查看远程库的简短名字 git remote -v 查看对应的远程克隆位置 添加远程仓库关联 git remote add [alias] [url] 添加远程仓库绑定 拉取数据 git fetch [alias] 通过此命令，可以将拉下远程仓库的快照 如果是git clone的方式获取的项目，默认origin为远程仓库的alias git pull [alias] [branch-name]拉取远程分支内容,并merge本地文件 推送数据 git push [alias] [branch-name] 推送数据至远程分支 查看远程仓库信息 git remote show [alias] 查看远程仓库具体信息 远程仓库关联重命名 git remote rename aliasA aliasB 远程仓库关联alias重命名 删除远程仓库关联 git remote rm alias 标签 在发布某个版本的时候，记得要打上标签，这样利于之后项目盘点和回滚 标签操作 git tag 查看所有的tag git tag -l [regex] 查看正则匹配的tag git tag -a [tag-name] -m &quot;description&quot; 新增带批注说明的标签 git show [tag-name] 查看标签具体信息 git tag -a [tag-name] [commit-no]对历史提交版本打标签 默认情况下git push 不会提交标签，通过git push [alias] [tag-name]提交指定标签,也可以通过git push [alias] --tags,将所有本地标签推送至远程 alias 有时候为了少敲几个字符,可以使用别名 git config --global alias.co checkout 这样就可以使用git co 来代替checkout 文档参考]]></content>
      <tags>
        <tag>git</tag>
        <tag>cvs</tag>
      </tags>
  </entry>
</search>
